import {
  forwardRef,
  Inject,
  Injectable,
  InternalServerErrorException,
  Logger,
  LoggerService,
  NotFoundException,
} from '@nestjs/common';
import { CreateCategoryDto } from './dto/create-category.dto';
import { DatabaseService } from 'src/database/database.service';
import { BucketService } from 'src/amazon-bucket/bucket.service';
import { Category } from '@prisma/client';
import { NotFoundError } from 'rxjs';
import { UpdateCategoryDto } from './dto/update-category.dto';

@Injectable()
export class CategoriesService {
  constructor(
    private prisma: DatabaseService,
    @Inject(forwardRef(() => BucketService)) private s3: BucketService,
  ) {

  }

  isMulterFile(file: any): file is Express.Multer.File {
    return (
      file &&
      typeof file === 'object' &&
      'fieldname' in file &&
      'originalname' in file &&
      'mimetype' in file &&
      'buffer' in file &&
      'size' in file
    );
  };

  private readonly logger = new Logger(CategoriesService.name)
  async updateCategory(
    id: string,
    category: UpdateCategoryDto,
  ) {
    try {
      const category_name = category.category_name
      const productToUpdate = await this.prisma.category.findFirst({
        where: {
          id: id,
        },
      });

      if (!productToUpdate) {
        throw new NotFoundException("No pudimos encontrar un producto con esa ID")
      }

      const update = await this.prisma.category.update({
        where: {
          id: id,
        },
        data: {
          category_name: category_name,
        },
      });

      return update;
    } catch (err) {
      this.logger.error("Un error ocurrio cuando se intentaba actualizar una categoria", err)
      throw new InternalServerErrorException("No se pudo actualizar la categoria, ocurrio un error inesperado", err)
    }
  }

  async createCategory(cat) {
    try {
      const newCategoryName = cat.category_name;

      const categoryAlreadyExists = await this.prisma.category.findFirst({
        where: {
          category_name: newCategoryName
        }
      })

      if (categoryAlreadyExists) throw new InternalServerErrorException("La categoria ya existe")

      const category = await this.prisma.category.create({
        data: {
          category_name: newCategoryName,
        },
      });

      if (!category) {
        throw new InternalServerErrorException("No se pudo crear la categoria")
      }

      return category;
    } catch (error: any) {
      throw new InternalServerErrorException(error);
    }
  }

  async getAllCategories() {
    try {
      const categories = await this.prisma.category.findMany();

      return categories;
    } catch (err: any) {
      this.logger.error("Hubo un error al tratar de obtener las categorias", err)
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async getAllCategoriesExcludingOne(category: string) {
    try {
      const categories = await this.prisma.category.findMany({
        where: {
          category_name: {
            not: category,
          },
        },
      });


      return categories;
    } catch (err: any) {
      this.logger.error("Hubo un error al obtener las categorias excluyendo una", err)
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async findCategoryById(id: string) {
    try {
      const category = await this.prisma.category.findFirst({
        where: {
          id: id,
        },
      });
      return category;
    } catch (error) {
      console.log(error);
    }
  }

  async findCategoryWithProducts(id: string) {
    try {
      const category = await this.prisma.category.findFirst({
        where: {
          id: id,
        },
      });

      if (!category) {
        throw new NotFoundException('Category not found');
      }

      try {
        const products = await this.prisma.product.findMany({
          where: {
            categoryId: category.id,
          },
          include: {
            product_category: {
              select: {
                category_name: true,
                id: true,
              },
            },
          },

        });

        for (const product of products) {
          product.product_images = await this.s3.getSignedUrlsFromImages('products', product.product_images) as string[]
        }

        return products;
      } catch (err) {
        console.log(err);
        throw new Error('Error fetching products or generating signed URLs');
      }
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async deleteCategory(id: string) {
    try {
      const categoryToDelete = await this.prisma.category.findUnique({
        where: {
          id: id,
        },
      });

      if (!categoryToDelete) {
        throw new Error(`No pudimos encontrar una categoria con esa ID (${id})`);
      }

      const deletedCategory = await this.prisma.category.delete({
        where: {
          id: id,
        },
      });

      return deletedCategory;
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }
}
