import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { Product, ProductFiles } from './interfaces/product.interfaces';
import { DatabaseService } from '../database/database.service';
import { BucketService } from 'src/amazon-bucket/bucket.service';

@Injectable()
export class ProductsService {
  /*    This lets us use the prisma functions in this service */
  constructor(
    private prisma: DatabaseService,
    private s3: BucketService,
  ) { }
  // Define the S3 client that will be used to interact with the S3 bucket

  async createProduct(
    createProductDto: CreateProductDto,
    files: (Express.Multer.File | string)[],
  ) {
    try {
      const imagesTransformed: string[] = [];

      for (let file of files) {
        imagesTransformed.push(await this.s3.createFile('products', file));
      }

      // Create the product
      const product = await this.prisma.product.create({
        data: {

          product_name: createProductDto.product_name,
          product_description: createProductDto.product_description,
          product_notes: createProductDto.product_notes,
          product_category: {
            connect: {
              category_name: createProductDto.product_category.product_category_name,
            },
          },
          product_price: createProductDto.product_price,
          product_images: imagesTransformed,
          product_tags: createProductDto.product_tags,

          product_quality: createProductDto.product_quality as 'ORIGINAL' | 'REACONDICIONADO'
        },
        include: {
          product_category: {
            select: {
              id: true,
              category_name: true,
            },
          },
        },
      });

      return product;
    } catch (err) {
      console.error(err);
      throw new InternalServerErrorException();
    }
  }

  async searchProduct(word: string): Promise<Product[]> {
    try {
      const productsFound = await this.prisma.product.findMany({
        where: {
          product_name: { contains: word, mode: 'insensitive' },
        },
        include: { product_category: { select: { category_name: true, id: true } } },
      });
      // ASSIGN THE IMAGES FOR EACH PRODUCT

      let productsToReturn = Promise.all(productsFound.map(async (product) => {
        product.product_images = await this.s3.getSignedUrlsFromImages('products', product.product_images) as string[];
        return product
      }))

      return productsToReturn
    } catch (error) {
      console.log(error);
      throw new NotFoundException(error);
    }
  }


  async deleteBulkProducts(payload: { products: string[] }) {

    const { products } = payload

    try {
      const response = await this.prisma.product.deleteMany({
        where: {
          id: {
            in: products
          }
        }
      })

      return response
    } catch (err) {
      console.log(err)
      throw new InternalServerErrorException(err)
    }
  }


  async updateProduct(
    id: string,
    updateProductDto: UpdateProductDto,
    files: ProductFiles,
  ) {
    try {
      // Extracts the newImages array from the files object
      const images = files['newImages[]'];

      // Get the existing product with the given ID
      const productToUpdate = await this.prisma.product.findFirst({
        where: { id: id },
      });

      if (!productToUpdate) {
        throw new NotFoundException('Product not found');
      }

      // Process and upload each file to S3 if there are new files
      let imagesTransformed: string[] = [];

      if (images?.length > 0) {
        for (const file of images) {
          imagesTransformed.push(await this.s3.createFile('products', file));
        }
      }

      // Combine existing images with new ones
      const updatedImages =
        imagesTransformed.length > 0
          ? [...productToUpdate.product_images, ...imagesTransformed]
          : productToUpdate.product_images;

      // Update the product
      const productUpdated = await this.prisma.product.update({
        where: { id: id },
        data: {
          product_name: updateProductDto.product_name,
          product_category: {
            connect: {
              category_name: updateProductDto.product_category.product_category_name,
            },
          },
          product_images: updatedImages,
          product_description: updateProductDto.product_description,
          product_price: updateProductDto.product_price,
          product_tags: updateProductDto.product_tags,
          product_notes: updateProductDto.product_notes,
          product_quality: updateProductDto.product_quality as
            | 'ORIGINAL'
            | 'REACONDICIONADO',
        },
        include: {
          product_category: {
            select: {
              category_name: true,
              id: true,
            },
          },
        },
      });

      return productUpdated;
    } catch (err: any) {
      console.log(err);
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async removeProduct(id: string) {
    const productToDelete = await this.prisma.product.findFirst({
      where: {
        id: id,
      },
    });

    if (!productToDelete) {
      throw new BadRequestException('No existe el producto');
    }

    // Delete the images from the s3 bucket
    for (const image of productToDelete.product_images) {
      await this.s3.deleteFile(image);
    }

    try {
      const productDeleted = await this.prisma.product.delete({
        where: {
          id: id,
        },
        include: {
          product_category: {
            select: {
              category_name: true,
              id: true,
            },
          },
        },
      });

      return productDeleted;
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async findSingleProduct(id: string) {
    try {
      const product = await this.prisma.product.findFirst({
        where: {
          id: id,
        },
        include: {
          product_category: {
            select: {
              category_name: true,
              id: true,
            },
          },
        },
      });

      const categories = await this.prisma.category.findMany();

      const imagesUrls = await this.s3.getSignedUrlsFromImages('products', product.product_images);
      product.product_images = imagesUrls as string[]
      return {
        product,
        categories
      };
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  /* 
    CART AND PRODUCTS
  */

  async getAllProducts() {
    try {
      const products = await this.prisma.product.findMany({
        include: {
          product_category: true
        }
      })
      return products
    } catch (err) {
      console.log(err)
      throw new NotFoundException()
    }
  }

  async getHomepageProducts(name: string, limit: number) {
    try {
      const products = await this.prisma.product.findMany({
        where: {
          product_category: {
            category_name: name,
          },
        },
        include: {
          product_category: {
            select: {
              category_name: true,
              id: true,
            },
          },
        },
        take: limit,
      });

      if (!products || products.length === 0) {
        throw new Error('No se pudieron encontrar productos');
      }

      for (const product of products) {
        product.product_images = (await this.s3.getSignedUrlsFromImages('products',
          product.product_images,
        )) as string[];
      }

      return products;
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message,
        status: err.status || 500,
      });
    }
  }

  async getCartImage(id: string): Promise<string[]> {
    const product = await this.prisma.product.findFirst({
      where: {
        id: id,
      },
    });

    try {
      const images = await this.s3.getSignedUrlsFromImages('products', product.product_images) as string[]
      return images
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async deleteImageFromProduct(id: string, image: string) {
    try {
      const product = await this.prisma.product.findFirst({
        where: {
          id: id,
        },
      });

      if (!product) {
        throw new BadRequestException('Product not found');
      }

      const productImages = product.product_images;

      const index = productImages.indexOf(image);

      if (index === -1) {
        throw new BadRequestException('Image not found');
      }

      await this.s3.deleteFile(productImages[index]);
      productImages.splice(index, 1);

      await this.prisma.product.update({
        where: { id: id },
        data: {
          product_images: productImages,
        },
      });
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }

  async getProductsByLimit(limit: string, id: string) {
    try {
      let products = [];
      let productsToReturn = []
      if (id) {
        products = await this.prisma.product.findMany({
          where: {
            id: {
              not: id,
            },
          },
          take: parseInt(limit),
        });
      } else {
        products = await this.prisma.product.findMany({
          take: parseInt(limit),
        });
      }

      for (const product of products) {
        let productToReturn: Product = product
        productToReturn.product_images = await this.s3.getSignedUrlsFromImages('products',
          product.product_images,
        ) as string[]
        productsToReturn.push(productToReturn)
      }

      return productsToReturn;
    } catch (err: any) {
      throw new InternalServerErrorException({
        message: err.message as string,
        status: 500,
      });
    }
  }
}

